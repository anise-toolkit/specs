// automatically generated by the FlatBuffers compiler, do not modify



use crate::common_generated::*;
use crate::time_generated::*;
use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod anise {

  use crate::common_generated::*;
  use crate::time_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod ephemeris {

  use crate::common_generated::*;
  use crate::time_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INTERPOLATOR: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INTERPOLATOR: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INTERPOLATOR: [Interpolator; 3] = [
  Interpolator::NONE,
  Interpolator::equal_time_steps,
  Interpolator::unequal_time_steps,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Interpolator(pub u8);
#[allow(non_upper_case_globals)]
impl Interpolator {
  pub const NONE: Self = Self(0);
  pub const equal_time_steps: Self = Self(1);
  pub const unequal_time_steps: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::equal_time_steps,
    Self::unequal_time_steps,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::equal_time_steps => Some("equal_time_steps"),
      Self::unequal_time_steps => Some("unequal_time_steps"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Interpolator {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Interpolator {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Interpolator {
    type Output = Interpolator;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Interpolator {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Interpolator {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Interpolator {}
pub struct InterpolatorUnionTableOffset {}

pub enum StateCoefficientsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StateCoefficients<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StateCoefficients<'a> {
    type Inner = StateCoefficients<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> StateCoefficients<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StateCoefficients { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StateCoefficientsArgs<'args>) -> flatbuffers::WIPOffset<StateCoefficients<'bldr>> {
      let mut builder = StateCoefficientsBuilder::new(_fbb);
      builder.add_usable_end_time_offset_s(args.usable_end_time_offset_s);
      builder.add_usable_start_time_offset_s(args.usable_start_time_offset_s);
      if let Some(x) = args.cov_vz_vz { builder.add_cov_vz_vz(x); }
      if let Some(x) = args.cov_vz_vy { builder.add_cov_vz_vy(x); }
      if let Some(x) = args.cov_vz_vx { builder.add_cov_vz_vx(x); }
      if let Some(x) = args.cov_vz_z { builder.add_cov_vz_z(x); }
      if let Some(x) = args.cov_vz_y { builder.add_cov_vz_y(x); }
      if let Some(x) = args.cov_vz_x { builder.add_cov_vz_x(x); }
      if let Some(x) = args.cov_vy_vy { builder.add_cov_vy_vy(x); }
      if let Some(x) = args.cov_vy_vx { builder.add_cov_vy_vx(x); }
      if let Some(x) = args.cov_vy_z { builder.add_cov_vy_z(x); }
      if let Some(x) = args.cov_vy_y { builder.add_cov_vy_y(x); }
      if let Some(x) = args.cov_vy_x { builder.add_cov_vy_x(x); }
      if let Some(x) = args.cov_vx_vx { builder.add_cov_vx_vx(x); }
      if let Some(x) = args.cov_vx_z { builder.add_cov_vx_z(x); }
      if let Some(x) = args.cov_vx_y { builder.add_cov_vx_y(x); }
      if let Some(x) = args.cov_vx_x { builder.add_cov_vx_x(x); }
      if let Some(x) = args.cov_z_z { builder.add_cov_z_z(x); }
      if let Some(x) = args.cov_z_y { builder.add_cov_z_y(x); }
      if let Some(x) = args.cov_z_x { builder.add_cov_z_x(x); }
      if let Some(x) = args.cov_y_y { builder.add_cov_y_y(x); }
      if let Some(x) = args.cov_y_x { builder.add_cov_y_x(x); }
      if let Some(x) = args.cov_x_x { builder.add_cov_x_x(x); }
      if let Some(x) = args.vz { builder.add_vz(x); }
      if let Some(x) = args.vy { builder.add_vy(x); }
      if let Some(x) = args.vx { builder.add_vx(x); }
      if let Some(x) = args.z { builder.add_z(x); }
      if let Some(x) = args.y { builder.add_y(x); }
      if let Some(x) = args.x { builder.add_x(x); }
      builder.finish()
    }

    pub const VT_USABLE_START_TIME_OFFSET_S: flatbuffers::VOffsetT = 4;
    pub const VT_USABLE_END_TIME_OFFSET_S: flatbuffers::VOffsetT = 6;
    pub const VT_X: flatbuffers::VOffsetT = 8;
    pub const VT_Y: flatbuffers::VOffsetT = 10;
    pub const VT_Z: flatbuffers::VOffsetT = 12;
    pub const VT_VX: flatbuffers::VOffsetT = 14;
    pub const VT_VY: flatbuffers::VOffsetT = 16;
    pub const VT_VZ: flatbuffers::VOffsetT = 18;
    pub const VT_COV_X_X: flatbuffers::VOffsetT = 20;
    pub const VT_COV_Y_X: flatbuffers::VOffsetT = 22;
    pub const VT_COV_Y_Y: flatbuffers::VOffsetT = 24;
    pub const VT_COV_Z_X: flatbuffers::VOffsetT = 26;
    pub const VT_COV_Z_Y: flatbuffers::VOffsetT = 28;
    pub const VT_COV_Z_Z: flatbuffers::VOffsetT = 30;
    pub const VT_COV_VX_X: flatbuffers::VOffsetT = 32;
    pub const VT_COV_VX_Y: flatbuffers::VOffsetT = 34;
    pub const VT_COV_VX_Z: flatbuffers::VOffsetT = 36;
    pub const VT_COV_VX_VX: flatbuffers::VOffsetT = 38;
    pub const VT_COV_VY_X: flatbuffers::VOffsetT = 40;
    pub const VT_COV_VY_Y: flatbuffers::VOffsetT = 42;
    pub const VT_COV_VY_Z: flatbuffers::VOffsetT = 44;
    pub const VT_COV_VY_VX: flatbuffers::VOffsetT = 46;
    pub const VT_COV_VY_VY: flatbuffers::VOffsetT = 48;
    pub const VT_COV_VZ_X: flatbuffers::VOffsetT = 50;
    pub const VT_COV_VZ_Y: flatbuffers::VOffsetT = 52;
    pub const VT_COV_VZ_Z: flatbuffers::VOffsetT = 54;
    pub const VT_COV_VZ_VX: flatbuffers::VOffsetT = 56;
    pub const VT_COV_VZ_VY: flatbuffers::VOffsetT = 58;
    pub const VT_COV_VZ_VZ: flatbuffers::VOffsetT = 60;

  #[inline]
  pub fn usable_start_time_offset_s(&self) -> f64 {
    self._tab.get::<f64>(StateCoefficients::VT_USABLE_START_TIME_OFFSET_S, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn usable_end_time_offset_s(&self) -> f64 {
    self._tab.get::<f64>(StateCoefficients::VT_USABLE_END_TIME_OFFSET_S, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_X, None)
  }
  #[inline]
  pub fn y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_Y, None)
  }
  #[inline]
  pub fn z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_Z, None)
  }
  #[inline]
  pub fn vx(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_VX, None)
  }
  #[inline]
  pub fn vy(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_VY, None)
  }
  #[inline]
  pub fn vz(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_VZ, None)
  }
  #[inline]
  pub fn cov_x_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_X_X, None)
  }
  #[inline]
  pub fn cov_y_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_Y_X, None)
  }
  #[inline]
  pub fn cov_y_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_Y_Y, None)
  }
  #[inline]
  pub fn cov_z_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_Z_X, None)
  }
  #[inline]
  pub fn cov_z_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_Z_Y, None)
  }
  #[inline]
  pub fn cov_z_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_Z_Z, None)
  }
  #[inline]
  pub fn cov_vx_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VX_X, None)
  }
  #[inline]
  pub fn cov_vx_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VX_Y, None)
  }
  #[inline]
  pub fn cov_vx_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VX_Z, None)
  }
  #[inline]
  pub fn cov_vx_vx(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VX_VX, None)
  }
  #[inline]
  pub fn cov_vy_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VY_X, None)
  }
  #[inline]
  pub fn cov_vy_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VY_Y, None)
  }
  #[inline]
  pub fn cov_vy_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VY_Z, None)
  }
  #[inline]
  pub fn cov_vy_vx(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VY_VX, None)
  }
  #[inline]
  pub fn cov_vy_vy(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VY_VY, None)
  }
  #[inline]
  pub fn cov_vz_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VZ_X, None)
  }
  #[inline]
  pub fn cov_vz_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VZ_Y, None)
  }
  #[inline]
  pub fn cov_vz_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VZ_Z, None)
  }
  #[inline]
  pub fn cov_vz_vx(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VZ_VX, None)
  }
  #[inline]
  pub fn cov_vz_vy(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VZ_VY, None)
  }
  #[inline]
  pub fn cov_vz_vz(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StateCoefficients::VT_COV_VZ_VZ, None)
  }
}

impl flatbuffers::Verifiable for StateCoefficients<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>(&"usable_start_time_offset_s", Self::VT_USABLE_START_TIME_OFFSET_S, false)?
     .visit_field::<f64>(&"usable_end_time_offset_s", Self::VT_USABLE_END_TIME_OFFSET_S, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"x", Self::VT_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"y", Self::VT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"z", Self::VT_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"vx", Self::VT_VX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"vy", Self::VT_VY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"vz", Self::VT_VZ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_x_x", Self::VT_COV_X_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_y_x", Self::VT_COV_Y_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_y_y", Self::VT_COV_Y_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_z_x", Self::VT_COV_Z_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_z_y", Self::VT_COV_Z_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_z_z", Self::VT_COV_Z_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vx_x", Self::VT_COV_VX_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vx_y", Self::VT_COV_VX_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vx_z", Self::VT_COV_VX_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vx_vx", Self::VT_COV_VX_VX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vy_x", Self::VT_COV_VY_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vy_y", Self::VT_COV_VY_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vy_z", Self::VT_COV_VY_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vy_vx", Self::VT_COV_VY_VX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vy_vy", Self::VT_COV_VY_VY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_x", Self::VT_COV_VZ_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_y", Self::VT_COV_VZ_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_z", Self::VT_COV_VZ_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_vx", Self::VT_COV_VZ_VX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_vy", Self::VT_COV_VZ_VY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_vz", Self::VT_COV_VZ_VZ, false)?
     .finish();
    Ok(())
  }
}
pub struct StateCoefficientsArgs<'a> {
    pub usable_start_time_offset_s: f64,
    pub usable_end_time_offset_s: f64,
    pub x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub vx: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub vy: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub vz: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_x_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_y_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_y_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_z_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_z_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_z_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vx_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vx_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vx_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vx_vx: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vy_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vy_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vy_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vy_vx: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vy_vy: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_vx: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_vy: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_vz: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for StateCoefficientsArgs<'a> {
    #[inline]
    fn default() -> Self {
        StateCoefficientsArgs {
            usable_start_time_offset_s: 0.0,
            usable_end_time_offset_s: 0.0,
            x: None,
            y: None,
            z: None,
            vx: None,
            vy: None,
            vz: None,
            cov_x_x: None,
            cov_y_x: None,
            cov_y_y: None,
            cov_z_x: None,
            cov_z_y: None,
            cov_z_z: None,
            cov_vx_x: None,
            cov_vx_y: None,
            cov_vx_z: None,
            cov_vx_vx: None,
            cov_vy_x: None,
            cov_vy_y: None,
            cov_vy_z: None,
            cov_vy_vx: None,
            cov_vy_vy: None,
            cov_vz_x: None,
            cov_vz_y: None,
            cov_vz_z: None,
            cov_vz_vx: None,
            cov_vz_vy: None,
            cov_vz_vz: None,
        }
    }
}
pub struct StateCoefficientsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StateCoefficientsBuilder<'a, 'b> {
  #[inline]
  pub fn add_usable_start_time_offset_s(&mut self, usable_start_time_offset_s: f64) {
    self.fbb_.push_slot::<f64>(StateCoefficients::VT_USABLE_START_TIME_OFFSET_S, usable_start_time_offset_s, 0.0);
  }
  #[inline]
  pub fn add_usable_end_time_offset_s(&mut self, usable_end_time_offset_s: f64) {
    self.fbb_.push_slot::<f64>(StateCoefficients::VT_USABLE_END_TIME_OFFSET_S, usable_end_time_offset_s, 0.0);
  }
  #[inline]
  pub fn add_x(&mut self, x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_X, x);
  }
  #[inline]
  pub fn add_y(&mut self, y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_Y, y);
  }
  #[inline]
  pub fn add_z(&mut self, z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_Z, z);
  }
  #[inline]
  pub fn add_vx(&mut self, vx: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_VX, vx);
  }
  #[inline]
  pub fn add_vy(&mut self, vy: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_VY, vy);
  }
  #[inline]
  pub fn add_vz(&mut self, vz: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_VZ, vz);
  }
  #[inline]
  pub fn add_cov_x_x(&mut self, cov_x_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_X_X, cov_x_x);
  }
  #[inline]
  pub fn add_cov_y_x(&mut self, cov_y_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_Y_X, cov_y_x);
  }
  #[inline]
  pub fn add_cov_y_y(&mut self, cov_y_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_Y_Y, cov_y_y);
  }
  #[inline]
  pub fn add_cov_z_x(&mut self, cov_z_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_Z_X, cov_z_x);
  }
  #[inline]
  pub fn add_cov_z_y(&mut self, cov_z_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_Z_Y, cov_z_y);
  }
  #[inline]
  pub fn add_cov_z_z(&mut self, cov_z_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_Z_Z, cov_z_z);
  }
  #[inline]
  pub fn add_cov_vx_x(&mut self, cov_vx_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VX_X, cov_vx_x);
  }
  #[inline]
  pub fn add_cov_vx_y(&mut self, cov_vx_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VX_Y, cov_vx_y);
  }
  #[inline]
  pub fn add_cov_vx_z(&mut self, cov_vx_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VX_Z, cov_vx_z);
  }
  #[inline]
  pub fn add_cov_vx_vx(&mut self, cov_vx_vx: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VX_VX, cov_vx_vx);
  }
  #[inline]
  pub fn add_cov_vy_x(&mut self, cov_vy_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VY_X, cov_vy_x);
  }
  #[inline]
  pub fn add_cov_vy_y(&mut self, cov_vy_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VY_Y, cov_vy_y);
  }
  #[inline]
  pub fn add_cov_vy_z(&mut self, cov_vy_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VY_Z, cov_vy_z);
  }
  #[inline]
  pub fn add_cov_vy_vx(&mut self, cov_vy_vx: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VY_VX, cov_vy_vx);
  }
  #[inline]
  pub fn add_cov_vy_vy(&mut self, cov_vy_vy: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VY_VY, cov_vy_vy);
  }
  #[inline]
  pub fn add_cov_vz_x(&mut self, cov_vz_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VZ_X, cov_vz_x);
  }
  #[inline]
  pub fn add_cov_vz_y(&mut self, cov_vz_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VZ_Y, cov_vz_y);
  }
  #[inline]
  pub fn add_cov_vz_z(&mut self, cov_vz_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VZ_Z, cov_vz_z);
  }
  #[inline]
  pub fn add_cov_vz_vx(&mut self, cov_vz_vx: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VZ_VX, cov_vz_vx);
  }
  #[inline]
  pub fn add_cov_vz_vy(&mut self, cov_vz_vy: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VZ_VY, cov_vz_vy);
  }
  #[inline]
  pub fn add_cov_vz_vz(&mut self, cov_vz_vz: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateCoefficients::VT_COV_VZ_VZ, cov_vz_vz);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StateCoefficientsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StateCoefficientsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StateCoefficients<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for StateCoefficients<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("StateCoefficients");
      ds.field("usable_start_time_offset_s", &self.usable_start_time_offset_s());
      ds.field("usable_end_time_offset_s", &self.usable_end_time_offset_s());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("z", &self.z());
      ds.field("vx", &self.vx());
      ds.field("vy", &self.vy());
      ds.field("vz", &self.vz());
      ds.field("cov_x_x", &self.cov_x_x());
      ds.field("cov_y_x", &self.cov_y_x());
      ds.field("cov_y_y", &self.cov_y_y());
      ds.field("cov_z_x", &self.cov_z_x());
      ds.field("cov_z_y", &self.cov_z_y());
      ds.field("cov_z_z", &self.cov_z_z());
      ds.field("cov_vx_x", &self.cov_vx_x());
      ds.field("cov_vx_y", &self.cov_vx_y());
      ds.field("cov_vx_z", &self.cov_vx_z());
      ds.field("cov_vx_vx", &self.cov_vx_vx());
      ds.field("cov_vy_x", &self.cov_vy_x());
      ds.field("cov_vy_y", &self.cov_vy_y());
      ds.field("cov_vy_z", &self.cov_vy_z());
      ds.field("cov_vy_vx", &self.cov_vy_vx());
      ds.field("cov_vy_vy", &self.cov_vy_vy());
      ds.field("cov_vz_x", &self.cov_vz_x());
      ds.field("cov_vz_y", &self.cov_vz_y());
      ds.field("cov_vz_z", &self.cov_vz_z());
      ds.field("cov_vz_vx", &self.cov_vz_vx());
      ds.field("cov_vz_vy", &self.cov_vz_vy());
      ds.field("cov_vz_vz", &self.cov_vz_vz());
      ds.finish()
  }
}
pub enum EqualTimeStepsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EqualTimeSteps<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EqualTimeSteps<'a> {
    type Inner = EqualTimeSteps<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> EqualTimeSteps<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EqualTimeSteps { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EqualTimeStepsArgs<'args>) -> flatbuffers::WIPOffset<EqualTimeSteps<'bldr>> {
      let mut builder = EqualTimeStepsBuilder::new(_fbb);
      builder.add_spline_duration_s(args.spline_duration_s);
      if let Some(x) = args.coefficient_data { builder.add_coefficient_data(x); }
      builder.finish()
    }

    pub const VT_SPLINE_DURATION_S: flatbuffers::VOffsetT = 4;
    pub const VT_COEFFICIENT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn spline_duration_s(&self) -> f64 {
    self._tab.get::<f64>(EqualTimeSteps::VT_SPLINE_DURATION_S, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn coefficient_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateCoefficients<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateCoefficients>>>>(EqualTimeSteps::VT_COEFFICIENT_DATA, None)
  }
}

impl flatbuffers::Verifiable for EqualTimeSteps<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>(&"spline_duration_s", Self::VT_SPLINE_DURATION_S, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StateCoefficients>>>>(&"coefficient_data", Self::VT_COEFFICIENT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct EqualTimeStepsArgs<'a> {
    pub spline_duration_s: f64,
    pub coefficient_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateCoefficients<'a>>>>>,
}
impl<'a> Default for EqualTimeStepsArgs<'a> {
    #[inline]
    fn default() -> Self {
        EqualTimeStepsArgs {
            spline_duration_s: 0.0,
            coefficient_data: None,
        }
    }
}
pub struct EqualTimeStepsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EqualTimeStepsBuilder<'a, 'b> {
  #[inline]
  pub fn add_spline_duration_s(&mut self, spline_duration_s: f64) {
    self.fbb_.push_slot::<f64>(EqualTimeSteps::VT_SPLINE_DURATION_S, spline_duration_s, 0.0);
  }
  #[inline]
  pub fn add_coefficient_data(&mut self, coefficient_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StateCoefficients<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EqualTimeSteps::VT_COEFFICIENT_DATA, coefficient_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EqualTimeStepsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EqualTimeStepsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EqualTimeSteps<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for EqualTimeSteps<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("EqualTimeSteps");
      ds.field("spline_duration_s", &self.spline_duration_s());
      ds.field("coefficient_data", &self.coefficient_data());
      ds.finish()
  }
}
pub enum UnequalTimeStepsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnequalTimeSteps<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnequalTimeSteps<'a> {
    type Inner = UnequalTimeSteps<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> UnequalTimeSteps<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnequalTimeSteps { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnequalTimeStepsArgs<'args>) -> flatbuffers::WIPOffset<UnequalTimeSteps<'bldr>> {
      let mut builder = UnequalTimeStepsBuilder::new(_fbb);
      builder.add_time_normalization_max(args.time_normalization_max);
      builder.add_time_normalization_min(args.time_normalization_min);
      if let Some(x) = args.coefficient_data { builder.add_coefficient_data(x); }
      if let Some(x) = args.spline_time_index_s { builder.add_spline_time_index_s(x); }
      builder.finish()
    }

    pub const VT_SPLINE_TIME_INDEX_S: flatbuffers::VOffsetT = 4;
    pub const VT_COEFFICIENT_DATA: flatbuffers::VOffsetT = 6;
    pub const VT_TIME_NORMALIZATION_MIN: flatbuffers::VOffsetT = 8;
    pub const VT_TIME_NORMALIZATION_MAX: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn spline_time_index_s(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(UnequalTimeSteps::VT_SPLINE_TIME_INDEX_S, None)
  }
  #[inline]
  pub fn coefficient_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateCoefficients<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateCoefficients>>>>(UnequalTimeSteps::VT_COEFFICIENT_DATA, None)
  }
  #[inline]
  pub fn time_normalization_min(&self) -> f64 {
    self._tab.get::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MIN, Some(-1.0)).unwrap()
  }
  #[inline]
  pub fn time_normalization_max(&self) -> f64 {
    self._tab.get::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MAX, Some(+1.0)).unwrap()
  }
}

impl flatbuffers::Verifiable for UnequalTimeSteps<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"spline_time_index_s", Self::VT_SPLINE_TIME_INDEX_S, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StateCoefficients>>>>(&"coefficient_data", Self::VT_COEFFICIENT_DATA, false)?
     .visit_field::<f64>(&"time_normalization_min", Self::VT_TIME_NORMALIZATION_MIN, false)?
     .visit_field::<f64>(&"time_normalization_max", Self::VT_TIME_NORMALIZATION_MAX, false)?
     .finish();
    Ok(())
  }
}
pub struct UnequalTimeStepsArgs<'a> {
    pub spline_time_index_s: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub coefficient_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateCoefficients<'a>>>>>,
    pub time_normalization_min: f64,
    pub time_normalization_max: f64,
}
impl<'a> Default for UnequalTimeStepsArgs<'a> {
    #[inline]
    fn default() -> Self {
        UnequalTimeStepsArgs {
            spline_time_index_s: None,
            coefficient_data: None,
            time_normalization_min: -1.0,
            time_normalization_max: +1.0,
        }
    }
}
pub struct UnequalTimeStepsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnequalTimeStepsBuilder<'a, 'b> {
  #[inline]
  pub fn add_spline_time_index_s(&mut self, spline_time_index_s: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnequalTimeSteps::VT_SPLINE_TIME_INDEX_S, spline_time_index_s);
  }
  #[inline]
  pub fn add_coefficient_data(&mut self, coefficient_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StateCoefficients<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnequalTimeSteps::VT_COEFFICIENT_DATA, coefficient_data);
  }
  #[inline]
  pub fn add_time_normalization_min(&mut self, time_normalization_min: f64) {
    self.fbb_.push_slot::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MIN, time_normalization_min, -1.0);
  }
  #[inline]
  pub fn add_time_normalization_max(&mut self, time_normalization_max: f64) {
    self.fbb_.push_slot::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MAX, time_normalization_max, +1.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnequalTimeStepsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnequalTimeStepsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnequalTimeSteps<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for UnequalTimeSteps<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("UnequalTimeSteps");
      ds.field("spline_time_index_s", &self.spline_time_index_s());
      ds.field("coefficient_data", &self.coefficient_data());
      ds.field("time_normalization_min", &self.time_normalization_min());
      ds.field("time_normalization_max", &self.time_normalization_max());
      ds.finish()
  }
}
pub enum EphemerisOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Ephemeris<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ephemeris<'a> {
    type Inner = Ephemeris<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Ephemeris<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Ephemeris { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EphemerisArgs<'args>) -> flatbuffers::WIPOffset<Ephemeris<'bldr>> {
      let mut builder = EphemerisBuilder::new(_fbb);
      if let Some(x) = args.children { builder.add_children(x); }
      if let Some(x) = args.constants { builder.add_constants(x); }
      if let Some(x) = args.interpolator { builder.add_interpolator(x); }
      if let Some(x) = args.start_epoch { builder.add_start_epoch(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_interpolator_type(args.interpolator_type);
      builder.add_interpolation_kind(args.interpolation_kind);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_START_EPOCH: flatbuffers::VOffsetT = 6;
    pub const VT_INTERPOLATION_KIND: flatbuffers::VOffsetT = 8;
    pub const VT_INTERPOLATOR_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_INTERPOLATOR: flatbuffers::VOffsetT = 12;
    pub const VT_CONSTANTS: flatbuffers::VOffsetT = 14;
    pub const VT_CHILDREN: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn start_epoch(&self) -> &'a super::time::Epoch {
    self._tab.get::<super::time::Epoch>(Ephemeris::VT_START_EPOCH, None).unwrap()
  }
  #[inline]
  pub fn interpolation_kind(&self) -> super::common::InterpolationKind {
    self._tab.get::<super::common::InterpolationKind>(Ephemeris::VT_INTERPOLATION_KIND, Some(super::common::InterpolationKind::Chebyshev)).unwrap()
  }
  #[inline]
  pub fn interpolator_type(&self) -> Interpolator {
    self._tab.get::<Interpolator>(Ephemeris::VT_INTERPOLATOR_TYPE, Some(Interpolator::NONE)).unwrap()
  }
  #[inline]
  pub fn interpolator(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Ephemeris::VT_INTERPOLATOR, None).unwrap()
  }
  #[inline]
  pub fn constants(&self) -> Option<super::common::ConstantMap<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ConstantMap>>(Ephemeris::VT_CONSTANTS, None)
  }
  #[inline]
  pub fn children(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ephemeris<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ephemeris>>>>(Ephemeris::VT_CHILDREN, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolator_as_equal_time_steps(&self) -> Option<EqualTimeSteps<'a>> {
    if self.interpolator_type() == Interpolator::equal_time_steps {
      let u = self.interpolator();
      Some(EqualTimeSteps::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolator_as_unequal_time_steps(&self) -> Option<UnequalTimeSteps<'a>> {
    if self.interpolator_type() == Interpolator::unequal_time_steps {
      let u = self.interpolator();
      Some(UnequalTimeSteps::init_from_table(u))
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Ephemeris<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
     .visit_field::<super::time::Epoch>(&"start_epoch", Self::VT_START_EPOCH, true)?
     .visit_field::<super::common::InterpolationKind>(&"interpolation_kind", Self::VT_INTERPOLATION_KIND, false)?
     .visit_union::<Interpolator, _>(&"interpolator_type", Self::VT_INTERPOLATOR_TYPE, &"interpolator", Self::VT_INTERPOLATOR, true, |key, v, pos| {
        match key {
          Interpolator::equal_time_steps => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EqualTimeSteps>>("Interpolator::equal_time_steps", pos),
          Interpolator::unequal_time_steps => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnequalTimeSteps>>("Interpolator::unequal_time_steps", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ConstantMap>>(&"constants", Self::VT_CONSTANTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Ephemeris>>>>(&"children", Self::VT_CHILDREN, false)?
     .finish();
    Ok(())
  }
}
pub struct EphemerisArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub start_epoch: Option<&'a super::time::Epoch>,
    pub interpolation_kind: super::common::InterpolationKind,
    pub interpolator_type: Interpolator,
    pub interpolator: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub constants: Option<flatbuffers::WIPOffset<super::common::ConstantMap<'a>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Ephemeris<'a>>>>>,
}
impl<'a> Default for EphemerisArgs<'a> {
    #[inline]
    fn default() -> Self {
        EphemerisArgs {
            name: None, // required field
            start_epoch: None, // required field
            interpolation_kind: super::common::InterpolationKind::Chebyshev,
            interpolator_type: Interpolator::NONE,
            interpolator: None, // required field
            constants: None,
            children: None,
        }
    }
}
pub struct EphemerisBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EphemerisBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris::VT_NAME, name);
  }
  #[inline]
  pub fn add_start_epoch(&mut self, start_epoch: &super::time::Epoch) {
    self.fbb_.push_slot_always::<&super::time::Epoch>(Ephemeris::VT_START_EPOCH, start_epoch);
  }
  #[inline]
  pub fn add_interpolation_kind(&mut self, interpolation_kind: super::common::InterpolationKind) {
    self.fbb_.push_slot::<super::common::InterpolationKind>(Ephemeris::VT_INTERPOLATION_KIND, interpolation_kind, super::common::InterpolationKind::Chebyshev);
  }
  #[inline]
  pub fn add_interpolator_type(&mut self, interpolator_type: Interpolator) {
    self.fbb_.push_slot::<Interpolator>(Ephemeris::VT_INTERPOLATOR_TYPE, interpolator_type, Interpolator::NONE);
  }
  #[inline]
  pub fn add_interpolator(&mut self, interpolator: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris::VT_INTERPOLATOR, interpolator);
  }
  #[inline]
  pub fn add_constants(&mut self, constants: flatbuffers::WIPOffset<super::common::ConstantMap<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ConstantMap>>(Ephemeris::VT_CONSTANTS, constants);
  }
  #[inline]
  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Ephemeris<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris::VT_CHILDREN, children);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EphemerisBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EphemerisBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ephemeris<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Ephemeris::VT_NAME,"name");
    self.fbb_.required(o, Ephemeris::VT_START_EPOCH,"start_epoch");
    self.fbb_.required(o, Ephemeris::VT_INTERPOLATOR,"interpolator");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Ephemeris<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Ephemeris");
      ds.field("name", &self.name());
      ds.field("start_epoch", &self.start_epoch());
      ds.field("interpolation_kind", &self.interpolation_kind());
      ds.field("interpolator_type", &self.interpolator_type());
      match self.interpolator_type() {
        Interpolator::equal_time_steps => {
          if let Some(x) = self.interpolator_as_equal_time_steps() {
            ds.field("interpolator", &x)
          } else {
            ds.field("interpolator", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Interpolator::unequal_time_steps => {
          if let Some(x) = self.interpolator_as_unequal_time_steps() {
            ds.field("interpolator", &x)
          } else {
            ds.field("interpolator", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("interpolator", &x)
        },
      };
      ds.field("constants", &self.constants());
      ds.field("children", &self.children());
      ds.finish()
  }
}
}  // pub mod Ephemeris
}  // pub mod Anise

